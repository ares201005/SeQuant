#ifndef SEQUANT_CORE_CONTEXT_HPP
#define SEQUANT_CORE_CONTEXT_HPP

#include <SeQuant/core/attr.hpp>
#include <SeQuant/core/utility/context.hpp>

#include <cstddef>
#include <memory>

namespace sequant {

class IndexRegistry;

/// Specifies second quantization context, such as vacuum choice, whether index
/// spaces are orthonormal, sizes of index spaces, etc.
class Context {
 public:
  struct Defaults {
    constexpr static auto vacuum = Vacuum::Physical;
    constexpr static auto metric = IndexSpaceMetric::Unit;
    constexpr static auto braket_symmetry = BraKetSymmetry::conjugate;
    constexpr static auto spbasis = sequant::SPBasis::spinorbital;
    constexpr static auto first_dummy_index_ordinal = 100;
  };

  /// @param vac a Vacuum object
  /// @param m an IndexSpaceMetric object
  /// @param bks a BraKetSymmetry object
  /// @param spb single-particle basis (spin-free or spin-dependent)
  /// @param fdio first dummy index ordinal
  explicit Context(Vacuum vac, IndexSpaceMetric m = Defaults::metric,
                   BraKetSymmetry bks = Defaults::braket_symmetry,
                   SPBasis spb = Defaults::spbasis,
                   std::size_t fdio = Defaults::first_dummy_index_ordinal);

  /// default constructor, equivalent to Context(Vacuum::Physical,
  /// IndexSpaceMetric::Unit, BraKetSymmetry::conjugate,
  /// sequant::SPBasis::spinorbital, 100)
  Context() = default;

  ~Context() = default;

  Context(const Context&) = default;
  Context& operator=(const Context&) = default;

  /// \return Vacuum of this context
  Vacuum vacuum() const;
  /// \return IndexSpaceMetric of this context
  IndexSpaceMetric metric() const;
  /// \return BraKetSymmetry of this context
  BraKetSymmetry braket_symmetry() const;
  /// \return SPBasis of this context
  SPBasis spbasis() const;
  /// \return first ordinal of the dummy indices generated by calls to
  /// Index::next_tmp_index when this context is active
  std::size_t first_dummy_index_ordinal() const;

  /// Sets the Vacuum for this context, convenient for chaining
  /// \param vacuum Vacuum
  /// \return ref to `*this`, for chaining
  Context& set(Vacuum vacuum);
  /// Sets the IndexSpaceMetric for this context, convenient for chaining
  /// \param metric IndexSpaceMetric
  /// \return ref to `*this`, for chaining
  Context& set(IndexSpaceMetric metric);
  /// Sets the BraKetSymmetry for this context, convenient for chaining
  /// \param braket_symmetry BraKetSymmetry
  /// \return ref to `*this`, for chaining
  Context& set(BraKetSymmetry braket_symmetry);
  /// Sets the SPBasis for this context, convenient for chaining
  /// \param spbasis SPBasis
  /// \return ref to `*this`, for chaining
  Context& set(SPBasis spbasis);
  /// Sets the first dummy index ordinal for this context, convenient for
  /// chaining \param first_dummy_index_ordinal the first dummy index ordinal
  /// \return ref to `*this`, for chaining
  Context& set_first_dummy_index_ordinal(std::size_t first_dummy_index_ordinal);

  /// @return the IndexRegistry object
  std::shared_ptr<IndexRegistry> index_registry() const;

 private:
  Vacuum vacuum_ = Defaults::vacuum;
  IndexSpaceMetric metric_ = Defaults::metric;
  BraKetSymmetry braket_symmetry_ = Defaults::braket_symmetry;
  SPBasis spbasis_ = Defaults::spbasis;
  std::size_t first_dummy_index_ordinal_ = Defaults::first_dummy_index_ordinal;
};

/// old name of Context is a deprecated alias
using SeQuant
    [[deprecated("use sequant::Context instead of sequant::SeQuant")]] =
        Context;

/// Context object equality comparison
/// \param ctx1
/// \param ctx2
/// \return true if \p ctx1 and \p ctx2 are equal
/// \warning does not compare index registries
bool operator==(const Context& ctx1, const Context& ctx2);

/// Context object inequality comparison
/// \param ctx1
/// \param ctx2
/// \return true if \p ctx1 and \p ctx2 are not equal
/// \warning does not compare index registries
bool operator!=(const Context& ctx1, const Context& ctx2);

/// \name manipulation of implicit context for SeQuant

/// @{

const Context& get_default_context();
void set_default_context(const Context& ctx);
void reset_default_context();
[[nodiscard]] detail::ImplicitContextResetter<Context>
set_scoped_default_context(const Context& ctx);

///@}

}  // namespace sequant

#endif
